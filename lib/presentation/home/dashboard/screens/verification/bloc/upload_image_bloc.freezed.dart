// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'upload_image_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$UploadImageEventTearOff {
  const _$UploadImageEventTearOff();

  _Loading loading() {
    return const _Loading();
  }

  _FrontPicked frontPicked(Uint8List file) {
    return _FrontPicked(
      file,
    );
  }

  _BackPicked backPicked(Uint8List file) {
    return _BackPicked(
      file,
    );
  }

  _UtitlityPicked utitlityPicked(Uint8List file) {
    return _UtitlityPicked(
      file,
    );
  }
}

/// @nodoc
const $UploadImageEvent = _$UploadImageEventTearOff();

/// @nodoc
mixin _$UploadImageEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(Uint8List file) frontPicked,
    required TResult Function(Uint8List file) backPicked,
    required TResult Function(Uint8List file) utitlityPicked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(Uint8List file)? frontPicked,
    TResult Function(Uint8List file)? backPicked,
    TResult Function(Uint8List file)? utitlityPicked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(Uint8List file)? frontPicked,
    TResult Function(Uint8List file)? backPicked,
    TResult Function(Uint8List file)? utitlityPicked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_FrontPicked value) frontPicked,
    required TResult Function(_BackPicked value) backPicked,
    required TResult Function(_UtitlityPicked value) utitlityPicked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_FrontPicked value)? frontPicked,
    TResult Function(_BackPicked value)? backPicked,
    TResult Function(_UtitlityPicked value)? utitlityPicked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_FrontPicked value)? frontPicked,
    TResult Function(_BackPicked value)? backPicked,
    TResult Function(_UtitlityPicked value)? utitlityPicked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UploadImageEventCopyWith<$Res> {
  factory $UploadImageEventCopyWith(
          UploadImageEvent value, $Res Function(UploadImageEvent) then) =
      _$UploadImageEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$UploadImageEventCopyWithImpl<$Res>
    implements $UploadImageEventCopyWith<$Res> {
  _$UploadImageEventCopyWithImpl(this._value, this._then);

  final UploadImageEvent _value;
  // ignore: unused_field
  final $Res Function(UploadImageEvent) _then;
}

/// @nodoc
abstract class _$LoadingCopyWith<$Res> {
  factory _$LoadingCopyWith(_Loading value, $Res Function(_Loading) then) =
      __$LoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoadingCopyWithImpl<$Res> extends _$UploadImageEventCopyWithImpl<$Res>
    implements _$LoadingCopyWith<$Res> {
  __$LoadingCopyWithImpl(_Loading _value, $Res Function(_Loading) _then)
      : super(_value, (v) => _then(v as _Loading));

  @override
  _Loading get _value => super._value as _Loading;
}

/// @nodoc

class _$_Loading implements _Loading {
  const _$_Loading();

  @override
  String toString() {
    return 'UploadImageEvent.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Loading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(Uint8List file) frontPicked,
    required TResult Function(Uint8List file) backPicked,
    required TResult Function(Uint8List file) utitlityPicked,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(Uint8List file)? frontPicked,
    TResult Function(Uint8List file)? backPicked,
    TResult Function(Uint8List file)? utitlityPicked,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(Uint8List file)? frontPicked,
    TResult Function(Uint8List file)? backPicked,
    TResult Function(Uint8List file)? utitlityPicked,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_FrontPicked value) frontPicked,
    required TResult Function(_BackPicked value) backPicked,
    required TResult Function(_UtitlityPicked value) utitlityPicked,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_FrontPicked value)? frontPicked,
    TResult Function(_BackPicked value)? backPicked,
    TResult Function(_UtitlityPicked value)? utitlityPicked,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_FrontPicked value)? frontPicked,
    TResult Function(_BackPicked value)? backPicked,
    TResult Function(_UtitlityPicked value)? utitlityPicked,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements UploadImageEvent {
  const factory _Loading() = _$_Loading;
}

/// @nodoc
abstract class _$FrontPickedCopyWith<$Res> {
  factory _$FrontPickedCopyWith(
          _FrontPicked value, $Res Function(_FrontPicked) then) =
      __$FrontPickedCopyWithImpl<$Res>;
  $Res call({Uint8List file});
}

/// @nodoc
class __$FrontPickedCopyWithImpl<$Res>
    extends _$UploadImageEventCopyWithImpl<$Res>
    implements _$FrontPickedCopyWith<$Res> {
  __$FrontPickedCopyWithImpl(
      _FrontPicked _value, $Res Function(_FrontPicked) _then)
      : super(_value, (v) => _then(v as _FrontPicked));

  @override
  _FrontPicked get _value => super._value as _FrontPicked;

  @override
  $Res call({
    Object? file = freezed,
  }) {
    return _then(_FrontPicked(
      file == freezed
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$_FrontPicked implements _FrontPicked {
  const _$_FrontPicked(this.file);

  @override
  final Uint8List file;

  @override
  String toString() {
    return 'UploadImageEvent.frontPicked(file: $file)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FrontPicked &&
            const DeepCollectionEquality().equals(other.file, file));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(file));

  @JsonKey(ignore: true)
  @override
  _$FrontPickedCopyWith<_FrontPicked> get copyWith =>
      __$FrontPickedCopyWithImpl<_FrontPicked>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(Uint8List file) frontPicked,
    required TResult Function(Uint8List file) backPicked,
    required TResult Function(Uint8List file) utitlityPicked,
  }) {
    return frontPicked(file);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(Uint8List file)? frontPicked,
    TResult Function(Uint8List file)? backPicked,
    TResult Function(Uint8List file)? utitlityPicked,
  }) {
    return frontPicked?.call(file);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(Uint8List file)? frontPicked,
    TResult Function(Uint8List file)? backPicked,
    TResult Function(Uint8List file)? utitlityPicked,
    required TResult orElse(),
  }) {
    if (frontPicked != null) {
      return frontPicked(file);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_FrontPicked value) frontPicked,
    required TResult Function(_BackPicked value) backPicked,
    required TResult Function(_UtitlityPicked value) utitlityPicked,
  }) {
    return frontPicked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_FrontPicked value)? frontPicked,
    TResult Function(_BackPicked value)? backPicked,
    TResult Function(_UtitlityPicked value)? utitlityPicked,
  }) {
    return frontPicked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_FrontPicked value)? frontPicked,
    TResult Function(_BackPicked value)? backPicked,
    TResult Function(_UtitlityPicked value)? utitlityPicked,
    required TResult orElse(),
  }) {
    if (frontPicked != null) {
      return frontPicked(this);
    }
    return orElse();
  }
}

abstract class _FrontPicked implements UploadImageEvent {
  const factory _FrontPicked(Uint8List file) = _$_FrontPicked;

  Uint8List get file;
  @JsonKey(ignore: true)
  _$FrontPickedCopyWith<_FrontPicked> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$BackPickedCopyWith<$Res> {
  factory _$BackPickedCopyWith(
          _BackPicked value, $Res Function(_BackPicked) then) =
      __$BackPickedCopyWithImpl<$Res>;
  $Res call({Uint8List file});
}

/// @nodoc
class __$BackPickedCopyWithImpl<$Res>
    extends _$UploadImageEventCopyWithImpl<$Res>
    implements _$BackPickedCopyWith<$Res> {
  __$BackPickedCopyWithImpl(
      _BackPicked _value, $Res Function(_BackPicked) _then)
      : super(_value, (v) => _then(v as _BackPicked));

  @override
  _BackPicked get _value => super._value as _BackPicked;

  @override
  $Res call({
    Object? file = freezed,
  }) {
    return _then(_BackPicked(
      file == freezed
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$_BackPicked implements _BackPicked {
  const _$_BackPicked(this.file);

  @override
  final Uint8List file;

  @override
  String toString() {
    return 'UploadImageEvent.backPicked(file: $file)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BackPicked &&
            const DeepCollectionEquality().equals(other.file, file));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(file));

  @JsonKey(ignore: true)
  @override
  _$BackPickedCopyWith<_BackPicked> get copyWith =>
      __$BackPickedCopyWithImpl<_BackPicked>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(Uint8List file) frontPicked,
    required TResult Function(Uint8List file) backPicked,
    required TResult Function(Uint8List file) utitlityPicked,
  }) {
    return backPicked(file);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(Uint8List file)? frontPicked,
    TResult Function(Uint8List file)? backPicked,
    TResult Function(Uint8List file)? utitlityPicked,
  }) {
    return backPicked?.call(file);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(Uint8List file)? frontPicked,
    TResult Function(Uint8List file)? backPicked,
    TResult Function(Uint8List file)? utitlityPicked,
    required TResult orElse(),
  }) {
    if (backPicked != null) {
      return backPicked(file);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_FrontPicked value) frontPicked,
    required TResult Function(_BackPicked value) backPicked,
    required TResult Function(_UtitlityPicked value) utitlityPicked,
  }) {
    return backPicked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_FrontPicked value)? frontPicked,
    TResult Function(_BackPicked value)? backPicked,
    TResult Function(_UtitlityPicked value)? utitlityPicked,
  }) {
    return backPicked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_FrontPicked value)? frontPicked,
    TResult Function(_BackPicked value)? backPicked,
    TResult Function(_UtitlityPicked value)? utitlityPicked,
    required TResult orElse(),
  }) {
    if (backPicked != null) {
      return backPicked(this);
    }
    return orElse();
  }
}

abstract class _BackPicked implements UploadImageEvent {
  const factory _BackPicked(Uint8List file) = _$_BackPicked;

  Uint8List get file;
  @JsonKey(ignore: true)
  _$BackPickedCopyWith<_BackPicked> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$UtitlityPickedCopyWith<$Res> {
  factory _$UtitlityPickedCopyWith(
          _UtitlityPicked value, $Res Function(_UtitlityPicked) then) =
      __$UtitlityPickedCopyWithImpl<$Res>;
  $Res call({Uint8List file});
}

/// @nodoc
class __$UtitlityPickedCopyWithImpl<$Res>
    extends _$UploadImageEventCopyWithImpl<$Res>
    implements _$UtitlityPickedCopyWith<$Res> {
  __$UtitlityPickedCopyWithImpl(
      _UtitlityPicked _value, $Res Function(_UtitlityPicked) _then)
      : super(_value, (v) => _then(v as _UtitlityPicked));

  @override
  _UtitlityPicked get _value => super._value as _UtitlityPicked;

  @override
  $Res call({
    Object? file = freezed,
  }) {
    return _then(_UtitlityPicked(
      file == freezed
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$_UtitlityPicked implements _UtitlityPicked {
  const _$_UtitlityPicked(this.file);

  @override
  final Uint8List file;

  @override
  String toString() {
    return 'UploadImageEvent.utitlityPicked(file: $file)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UtitlityPicked &&
            const DeepCollectionEquality().equals(other.file, file));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(file));

  @JsonKey(ignore: true)
  @override
  _$UtitlityPickedCopyWith<_UtitlityPicked> get copyWith =>
      __$UtitlityPickedCopyWithImpl<_UtitlityPicked>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(Uint8List file) frontPicked,
    required TResult Function(Uint8List file) backPicked,
    required TResult Function(Uint8List file) utitlityPicked,
  }) {
    return utitlityPicked(file);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(Uint8List file)? frontPicked,
    TResult Function(Uint8List file)? backPicked,
    TResult Function(Uint8List file)? utitlityPicked,
  }) {
    return utitlityPicked?.call(file);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(Uint8List file)? frontPicked,
    TResult Function(Uint8List file)? backPicked,
    TResult Function(Uint8List file)? utitlityPicked,
    required TResult orElse(),
  }) {
    if (utitlityPicked != null) {
      return utitlityPicked(file);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_FrontPicked value) frontPicked,
    required TResult Function(_BackPicked value) backPicked,
    required TResult Function(_UtitlityPicked value) utitlityPicked,
  }) {
    return utitlityPicked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_FrontPicked value)? frontPicked,
    TResult Function(_BackPicked value)? backPicked,
    TResult Function(_UtitlityPicked value)? utitlityPicked,
  }) {
    return utitlityPicked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_FrontPicked value)? frontPicked,
    TResult Function(_BackPicked value)? backPicked,
    TResult Function(_UtitlityPicked value)? utitlityPicked,
    required TResult orElse(),
  }) {
    if (utitlityPicked != null) {
      return utitlityPicked(this);
    }
    return orElse();
  }
}

abstract class _UtitlityPicked implements UploadImageEvent {
  const factory _UtitlityPicked(Uint8List file) = _$_UtitlityPicked;

  Uint8List get file;
  @JsonKey(ignore: true)
  _$UtitlityPickedCopyWith<_UtitlityPicked> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$UploadImageStateTearOff {
  const _$UploadImageStateTearOff();

  _UploadImageState call(
      {required Uint8List frontFile,
      required Uint8List backFile,
      required Uint8List utilityFile,
      required bool submitting,
      required String response}) {
    return _UploadImageState(
      frontFile: frontFile,
      backFile: backFile,
      utilityFile: utilityFile,
      submitting: submitting,
      response: response,
    );
  }
}

/// @nodoc
const $UploadImageState = _$UploadImageStateTearOff();

/// @nodoc
mixin _$UploadImageState {
  Uint8List get frontFile => throw _privateConstructorUsedError;
  Uint8List get backFile => throw _privateConstructorUsedError;
  Uint8List get utilityFile => throw _privateConstructorUsedError;
  bool get submitting => throw _privateConstructorUsedError;
  String get response => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UploadImageStateCopyWith<UploadImageState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UploadImageStateCopyWith<$Res> {
  factory $UploadImageStateCopyWith(
          UploadImageState value, $Res Function(UploadImageState) then) =
      _$UploadImageStateCopyWithImpl<$Res>;
  $Res call(
      {Uint8List frontFile,
      Uint8List backFile,
      Uint8List utilityFile,
      bool submitting,
      String response});
}

/// @nodoc
class _$UploadImageStateCopyWithImpl<$Res>
    implements $UploadImageStateCopyWith<$Res> {
  _$UploadImageStateCopyWithImpl(this._value, this._then);

  final UploadImageState _value;
  // ignore: unused_field
  final $Res Function(UploadImageState) _then;

  @override
  $Res call({
    Object? frontFile = freezed,
    Object? backFile = freezed,
    Object? utilityFile = freezed,
    Object? submitting = freezed,
    Object? response = freezed,
  }) {
    return _then(_value.copyWith(
      frontFile: frontFile == freezed
          ? _value.frontFile
          : frontFile // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      backFile: backFile == freezed
          ? _value.backFile
          : backFile // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      utilityFile: utilityFile == freezed
          ? _value.utilityFile
          : utilityFile // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      submitting: submitting == freezed
          ? _value.submitting
          : submitting // ignore: cast_nullable_to_non_nullable
              as bool,
      response: response == freezed
          ? _value.response
          : response // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$UploadImageStateCopyWith<$Res>
    implements $UploadImageStateCopyWith<$Res> {
  factory _$UploadImageStateCopyWith(
          _UploadImageState value, $Res Function(_UploadImageState) then) =
      __$UploadImageStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {Uint8List frontFile,
      Uint8List backFile,
      Uint8List utilityFile,
      bool submitting,
      String response});
}

/// @nodoc
class __$UploadImageStateCopyWithImpl<$Res>
    extends _$UploadImageStateCopyWithImpl<$Res>
    implements _$UploadImageStateCopyWith<$Res> {
  __$UploadImageStateCopyWithImpl(
      _UploadImageState _value, $Res Function(_UploadImageState) _then)
      : super(_value, (v) => _then(v as _UploadImageState));

  @override
  _UploadImageState get _value => super._value as _UploadImageState;

  @override
  $Res call({
    Object? frontFile = freezed,
    Object? backFile = freezed,
    Object? utilityFile = freezed,
    Object? submitting = freezed,
    Object? response = freezed,
  }) {
    return _then(_UploadImageState(
      frontFile: frontFile == freezed
          ? _value.frontFile
          : frontFile // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      backFile: backFile == freezed
          ? _value.backFile
          : backFile // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      utilityFile: utilityFile == freezed
          ? _value.utilityFile
          : utilityFile // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      submitting: submitting == freezed
          ? _value.submitting
          : submitting // ignore: cast_nullable_to_non_nullable
              as bool,
      response: response == freezed
          ? _value.response
          : response // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_UploadImageState implements _UploadImageState {
  const _$_UploadImageState(
      {required this.frontFile,
      required this.backFile,
      required this.utilityFile,
      required this.submitting,
      required this.response});

  @override
  final Uint8List frontFile;
  @override
  final Uint8List backFile;
  @override
  final Uint8List utilityFile;
  @override
  final bool submitting;
  @override
  final String response;

  @override
  String toString() {
    return 'UploadImageState(frontFile: $frontFile, backFile: $backFile, utilityFile: $utilityFile, submitting: $submitting, response: $response)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UploadImageState &&
            const DeepCollectionEquality().equals(other.frontFile, frontFile) &&
            const DeepCollectionEquality().equals(other.backFile, backFile) &&
            const DeepCollectionEquality()
                .equals(other.utilityFile, utilityFile) &&
            const DeepCollectionEquality()
                .equals(other.submitting, submitting) &&
            const DeepCollectionEquality().equals(other.response, response));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(frontFile),
      const DeepCollectionEquality().hash(backFile),
      const DeepCollectionEquality().hash(utilityFile),
      const DeepCollectionEquality().hash(submitting),
      const DeepCollectionEquality().hash(response));

  @JsonKey(ignore: true)
  @override
  _$UploadImageStateCopyWith<_UploadImageState> get copyWith =>
      __$UploadImageStateCopyWithImpl<_UploadImageState>(this, _$identity);
}

abstract class _UploadImageState implements UploadImageState {
  const factory _UploadImageState(
      {required Uint8List frontFile,
      required Uint8List backFile,
      required Uint8List utilityFile,
      required bool submitting,
      required String response}) = _$_UploadImageState;

  @override
  Uint8List get frontFile;
  @override
  Uint8List get backFile;
  @override
  Uint8List get utilityFile;
  @override
  bool get submitting;
  @override
  String get response;
  @override
  @JsonKey(ignore: true)
  _$UploadImageStateCopyWith<_UploadImageState> get copyWith =>
      throw _privateConstructorUsedError;
}
